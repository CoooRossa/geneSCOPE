#' 5.SpatialWeights.r (2025-10-26)
#' @title Compute Spatial Weight Matrix and listw for a Grid Layer
#'
#' @description
#'   Builds a Queen-style neighbour list for the effective grid cells in a
#'   \code{scope_object} layer, then (optionally) converts it to a binary
#'   \code{dgCMatrix} and/or a \code{listw} object.  All outputs match the
#'   structure produced by the legacy implementation, but are generated via
#'   parallel C++ helpers for speed.
#'
#' @param scope_obj   A \code{scope_object} with at least one populated
#'                   \code{@grid} slot.
#' @param grid_name  Character. Name of the grid sub-layer to process. If
#'                   \code{NULL} and only one sub-layer exists, it is selected
#'                   automatically.
#' @param style      Character weighting style passed to
#'                   \code{spdep::nb2listw}. Default \code{"B"} (binary).
#' @param store_mat  Logical. If \code{TRUE} (default) store the binary
#'                   adjacency matrix in \code{$W}.
#' @param zero_policy Logical. Forwarded to \code{nb2listw}. When
#'                   \code{TRUE} (default) zero-neighbour regions are allowed.
#' @param store_listw Logical. If \code{TRUE} (default) store the \code{listw}
#'                   object in \code{$listw}.
#' @details
#'   Topology is detected automatically from the grid layer:
#'   - If row/column neighbour distances are ~equal, a square lattice is
#'     assumed and a Queen (8-neighbour) adjacency is used.
#'   - Otherwise, a hex lattice is assumed. The function then infers flat-top
#'     (row-offset; odd-r by default) vs pointy-top (column-offset; odd-q by
#'     default) from neighbour angle concentrations and builds the
#'     corresponding 6-neighbour adjacency.
#' @param verbose Logical. Whether to print progress messages (default TRUE).
#'
#' @return The modified \code{scope_object} is returned invisibly.
#'
#' @details
#'   The full \eqn{h \times h} Queen lattice (\eqn{h = \max(xbins\_eff,
#'   ybins\_eff)}) is generated by \code{grid_nb_omp()}, then subset and
#'   relabelled to match active grid IDs in \code{grid_info}.  When
#'   \code{store_mat = TRUE}, the neighbour list is converted to a binary
#'   sparse matrix with \code{listw_B_omp()}, the diagonal is zeroed, and all
#'   non-zero entries are coerced to numeric \code{1}.  Dimension names are set
#'   to \code{grid_id}.
#'
#' @examples
#' \dontrun{
#' coord <- computeWeights(
#'   coord,
#'   grid_name   = "25um",
#'   style       = "W",
#'   store_mat   = TRUE,
#'   store_listw = TRUE
#' )
#' }
#' @importFrom RhpcBLASctl blas_set_num_threads
#' @importFrom spdep nb2listw
#' @export
computeWeights <- function(scope_obj,
                           grid_name = NULL,
                           style = "B",
                           store_mat = TRUE,
                           zero_policy = TRUE,
                           store_listw = TRUE,
                           verbose = TRUE) {
  if (verbose) message("[geneSCOPE::computeWeights] Computing spatial weights for grid layer")

  # Use OpenMP-only configuration for C++ spatial operations
  thread_config <- configureThreadsFor("openmp_only",
    ncores_requested = parallel::detectCores(),
    restore_after = TRUE
  )
  on.exit({
    restore_fn <- attr(thread_config, "restore_function")
    if (!is.null(restore_fn)) restore_fn()
  })

  # Force single-threaded BLAS for sparse matrix operations
  if (requireNamespace("RhpcBLASctl", quietly = TRUE)) {
    RhpcBLASctl::blas_set_num_threads(1)
  }

  ## ---------- 0. Select grid layer (helper) -------------------------------
  g_layer <- .selectGridLayer(scope_obj, grid_name)

  ## If grid_name not provided, fill back actual name for writing back
  if (is.null(grid_name)) {
    grid_name <- names(scope_obj@grid)[
      vapply(scope_obj@grid, identical, logical(1), g_layer)
    ]
  }

  grid_info <- g_layer$grid_info
  req_cols <- c("gx", "gy", "grid_id", "xbins_eff", "ybins_eff")
  if (!all(req_cols[1:3] %in% names(grid_info))) {
    stop("grid_info must contain columns: gx, gy, grid_id")
  }
  if (is.null(g_layer$xbins_eff) || is.null(g_layer$ybins_eff)) {
    stop("grid layer missing xbins_eff / ybins_eff metadata")
  }

  gx <- grid_info$gx
  gy <- grid_info$gy
  grid_id <- grid_info$grid_id
  xbins_eff <- g_layer$xbins_eff
  ybins_eff <- g_layer$ybins_eff

  if (any(gx < 1 | gx > xbins_eff | gy < 1 | gy > ybins_eff)) {
    stop("gx/gy exceed xbins_eff × ybins_eff range; check coordinates.")
  }

  if (verbose) {
    message(
      "[geneSCOPE::computeWeights] Grid dimensions: ", length(grid_id),
      " grids, ", ybins_eff, "×", xbins_eff, " lattice"
    )
  }

  ## ---------- 1. Auto-detect topology ----------------------------------------
  chosen_topology <- "queen"
  gi <- data.table::as.data.table(grid_info)
  if (!all(c("gx","gy","center_x","center_y") %in% names(gi))) {
    warning("[geneSCOPE::computeWeights] grid_info lacks centre coordinates; using Queen adjacency.")
  } else {
    # 1a) Angle-based detection first (more reliable for hex): build neighbour vectors
    a <- gi[, .(gx, gy, cx = center_x, cy = center_y)]
    mk <- function(dr, dc) {
      b <- a[, .(gx_nb = gx - dr, gy_nb = gy - dc, cx_nb = cx, cy_nb = cy)]
      m <- merge(a, b, by.x = c("gx","gy"), by.y = c("gx_nb","gy_nb"), all = FALSE)
      if (!nrow(m)) return(NULL)
      data.table::data.table(dx = m$cx_nb - m$cx, dy = m$cy_nb - m$cy)
    }
    edges_xy <- data.table::rbindlist(list(mk(0,1), mk(1,0), mk(1,1), mk(1,-1)), use.names = TRUE, fill = TRUE)
    detect_by_angle <- FALSE
    if (!is.null(edges_xy) && nrow(edges_xy)) {
      th <- abs(atan2(edges_xy$dy, edges_xy$dx) * 180 / pi)
      horiz <- mean(pmin(th, 180 - th) <= 15, na.rm = TRUE)
      vert  <- mean(abs(th - 90) <= 15, na.rm = TRUE)
      # If either horizontal or vertical alignment is clearly present, treat as hex
      if (is.finite(horiz) && is.finite(vert) && max(horiz, vert) >= 0.15) {
        chosen_topology <- if (horiz >= vert) "hex-oddr" else "hex-oddq"
        detect_by_angle <- TRUE
      }
    }
    # 1b) Fallback: distance ratio heuristic (only if angle not decisive)
    if (!detect_by_angle) {
      neighbor_pairs <- function(dr, dc) {
        a2 <- gi[, .(gx, gy, cx = center_x, cy = center_y)]
        b2 <- a2[, .(gx_nb = gx - dr, gy_nb = gy - dc, cx_nb = cx, cy_nb = cy)]
        m2 <- merge(a2, b2, by.x = c("gx","gy"), by.y = c("gx_nb","gy_nb"), all = FALSE)
        if (!nrow(m2)) return(numeric())
        sqrt((m2$cx_nb - m2$cx)^2 + (m2$cy_nb - m2$cy)^2)
      }
      dE <- neighbor_pairs(0, 1)
      dS <- neighbor_pairs(1, 0)
      medE <- if (length(dE)) stats::median(dE) else NA_real_
      medS <- if (length(dS)) stats::median(dS) else NA_real_
      if (is.finite(medE) && is.finite(medS) && abs(medE/medS - 1) > 0.1) {
        # Distances differ → assume hex; pick flat/pointy by angle if available else default flat-top
        chosen_topology <- if (exists("horiz") && exists("vert") && is.finite(horiz) && is.finite(vert)) {
          if (horiz >= vert) "hex-oddr" else "hex-oddq"
        } else "hex-oddr"
      } else {
        chosen_topology <- "queen"
      }
    }
    if (verbose) message("[geneSCOPE::computeWeights] Auto-detected topology: ", chosen_topology)
  }
  

  ## ---------- 2. Full-grid neighbourhood per (possibly auto) topology ---------
  if (chosen_topology == "queen" || chosen_topology == "rook") {
    full_nb <- grid_nb_omp(ybins_eff, xbins_eff, queen = (chosen_topology == "queen"))
    # standard mapping: row-major by (gy,gx)
    cell_id <- (gy - 1L) * xbins_eff + gx
  } else if (chosen_topology == "hex-oddr") {
    full_nb <- grid_nb_hex_omp(ybins_eff, xbins_eff, oddr = TRUE)
    cell_id <- (gy - 1L) * xbins_eff + gx
  } else if (chosen_topology == "hex-evenr") {
    full_nb <- grid_nb_hex_omp(ybins_eff, xbins_eff, oddr = FALSE)
    cell_id <- (gy - 1L) * xbins_eff + gx
  } else if (chosen_topology == "hex-oddq") {
    # Column-offset (pointy-top) using dedicated builder
    full_nb <- grid_nb_hexq_omp(ybins_eff, xbins_eff, oddq = TRUE)
    cell_id <- (gx - 1L) * ybins_eff + gy
  } else if (chosen_topology == "hex-evenq") {
    full_nb <- grid_nb_hexq_omp(ybins_eff, xbins_eff, oddq = FALSE)
    cell_id <- (gx - 1L) * ybins_eff + gy
  } else {
    stop("Unknown topology: ", chosen_topology)
  }

  ## ---------- 3. Subset and relabel ------------------------------------
  sub_nb <- full_nb[cell_id]
  relabel_nb <- lapply(sub_nb, function(v) {
    idx <- match(v, cell_id)
    idx[!is.na(idx)]
  })
  attr(relabel_nb, "class") <- "nb"
  attr(relabel_nb, "region.id") <- grid_id
  attr(relabel_nb, "queen") <- identical(chosen_topology, "queen")
  attr(relabel_nb, "topology") <- chosen_topology

  # ——— Avoid spdep::card() error on zero-length vectors ———
  if (zero_policy) {
    zero_idx <- which(vapply(relabel_nb, length, integer(1)) == 0L)
    if (length(zero_idx) > 0L) {
      # Temporarily use its own index as neighbor, diag(W)=0 will remove later
      for (j in zero_idx) {
        relabel_nb[[j]] <- j
      }
    }
  }

  ## ---------- 3. listw / matrix --------------------------------------
  if (store_listw || store_mat) {
    listw_obj <- spdep::nb2listw(relabel_nb,
      style = style,
      zero.policy = zero_policy
    )
  }

  if (store_mat) {
    W <- listw_B_omp(relabel_nb)
    diag(W) <- 0
    W@x[] <- 1
    dimnames(W) <- list(grid_id, grid_id)
    scope_obj@grid[[grid_name]]$W <- W
  }
  if (store_listw) {
    scope_obj@grid[[grid_name]]$listw <- listw_obj
  }

  if (verbose) message("[geneSCOPE::computeWeights] Spatial weights computation completed")

  invisible(scope_obj)
}
