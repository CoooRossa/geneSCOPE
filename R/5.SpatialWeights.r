#' 5.SpatialWeights.r (2025-06-27)
#' @title Compute Spatial Weight Matrix and listw for a Grid Layer
#'
#' @description
#'   Builds a Queen-style neighbour list for the effective grid cells in a
#'   \code{scope_object} layer, then (optionally) converts it to a binary
#'   \code{dgCMatrix} and/or a \code{listw} object.  All outputs match the
#'   structure produced by the legacy implementation, but are generated via
#'   parallel C++ helpers for speed.
#'
#' @param scope_obj   A \code{scope_object} with at least one populated
#'                   \code{@grid} slot.
#' @param grid_name  Character. Name of the grid sub-layer to process. If
#'                   \code{NULL} and only one sub-layer exists, it is selected
#'                   automatically.
#' @param style      Character weighting style passed to
#'                   \code{spdep::nb2listw}. Default \code{"B"} (binary).
#' @param store_mat  Logical. If \code{TRUE} (default) store the binary
#'                   adjacency matrix in \code{$W}.
#' @param zero_policy Logical. Forwarded to \code{nb2listw}. When
#'                   \code{TRUE} (default) zero-neighbour regions are allowed.
#' @param store_listw Logical. If \code{TRUE} (default) store the \code{listw}
#'                   object in \code{$listw}.
#' @param verbose Logical. Whether to print progress messages (default TRUE).
#'
#' @return The modified \code{scope_object} is returned invisibly.
#'
#' @details
#'   The full \eqn{h \times h} Queen lattice (\eqn{h = \max(xbins\_eff,
#'   ybins\_eff)}) is generated by \code{grid_nb_omp()}, then subset and
#'   relabelled to match active grid IDs in \code{grid_info}.  When
#'   \code{store_mat = TRUE}, the neighbour list is converted to a binary
#'   sparse matrix with \code{listw_B_omp()}, the diagonal is zeroed, and all
#'   non-zero entries are coerced to numeric \code{1}.  Dimension names are set
#'   to \code{grid_id}.
#'
#' @examples
#' \dontrun{
#' coord <- computeWeights(
#'   coord,
#'   grid_name   = "25um",
#'   style       = "W",
#'   store_mat   = TRUE,
#'   store_listw = TRUE
#' )
#' }
#' @importFrom RhpcBLASctl blas_set_num_threads
#' @importFrom spdep nb2listw
#' @export
computeWeights <- function(scope_obj,
                           grid_name = NULL,
                           style = "B",
                           store_mat = TRUE,
                           zero_policy = TRUE,
                           store_listw = TRUE,
                           verbose = TRUE) {
  if (verbose) message("[geneSCOPE::computeWeights] Computing spatial weights for grid layer")

  # Use OpenMP-only configuration for C++ spatial operations
  thread_config <- configureThreadsFor("openmp_only",
    ncores_requested = parallel::detectCores(),
    restore_after = TRUE
  )
  on.exit({
    restore_fn <- attr(thread_config, "restore_function")
    if (!is.null(restore_fn)) restore_fn()
  })

  # Force single-threaded BLAS for sparse matrix operations
  if (requireNamespace("RhpcBLASctl", quietly = TRUE)) {
    RhpcBLASctl::blas_set_num_threads(1)
  }

  ## ---------- 0. Select grid layer (helper) -------------------------------
  g_layer <- .selectGridLayer(scope_obj, grid_name)

  ## If grid_name not provided, fill back actual name for writing back
  if (is.null(grid_name)) {
    grid_name <- names(scope_obj@grid)[
      vapply(scope_obj@grid, identical, logical(1), g_layer)
    ]
  }

  grid_info <- g_layer$grid_info
  req_cols <- c("gx", "gy", "grid_id", "xbins_eff", "ybins_eff")
  if (!all(req_cols[1:3] %in% names(grid_info))) {
    stop("grid_info must contain columns: gx, gy, grid_id")
  }
  if (is.null(g_layer$xbins_eff) || is.null(g_layer$ybins_eff)) {
    stop("grid layer missing xbins_eff / ybins_eff metadata")
  }

  gx <- grid_info$gx
  gy <- grid_info$gy
  grid_id <- grid_info$grid_id
  xbins_eff <- g_layer$xbins_eff
  ybins_eff <- g_layer$ybins_eff
  hbins <- max(xbins_eff, ybins_eff)

  if (any(gx < 1 | gx > hbins | gy < 1 | gy > hbins)) {
    stop("gx/gy exceed hbins × hbins range; check coordinates.")
  }

  if (verbose) {
    message(
      "[geneSCOPE::computeWeights] Grid dimensions: ", length(grid_id), " grids, ",
      hbins, "×", hbins, " lattice"
    )
  }

  ## ---------- 1. Full grid Queen neighborhood ---------------------------------
  full_nb <- grid_nb_omp(hbins, hbins, queen = TRUE)

  ## ---------- 2. Subset and relabel ------------------------------------
  cell_id <- (gy - 1L) * hbins + gx # Row-major order
  sub_nb <- full_nb[cell_id]
  relabel_nb <- lapply(sub_nb, function(v) {
    idx <- match(v, cell_id)
    idx[!is.na(idx)]
  })
  attr(relabel_nb, "class") <- "nb"
  attr(relabel_nb, "region.id") <- grid_id
  attr(relabel_nb, "queen") <- TRUE

  # ——— Avoid spdep::card() error on zero-length vectors ———
  if (zero_policy) {
    zero_idx <- which(vapply(relabel_nb, length, integer(1)) == 0L)
    if (length(zero_idx) > 0L) {
      # Temporarily use its own index as neighbor, diag(W)=0 will remove later
      for (j in zero_idx) {
        relabel_nb[[j]] <- j
      }
    }
  }

  ## ---------- 3. listw / matrix --------------------------------------
  if (store_listw || store_mat) {
    listw_obj <- spdep::nb2listw(relabel_nb,
      style = style,
      zero.policy = zero_policy
    )
  }

  if (store_mat) {
    W <- listw_B_omp(relabel_nb)
    diag(W) <- 0
    W@x[] <- 1
    dimnames(W) <- list(grid_id, grid_id)
    scope_obj@grid[[grid_name]]$W <- W
  }
  if (store_listw) {
    scope_obj@grid[[grid_name]]$listw <- listw_obj
  }

  if (verbose) message("[geneSCOPE::computeWeights] Spatial weights computation completed")

  invisible(scope_obj)
}
