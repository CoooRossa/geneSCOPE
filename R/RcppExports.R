# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Build Queen or Rook Neighbourhood List in Parallel
#'
#' @description
#'   Creates a spatial neighbourhood list for a rectangular grid using either
#'   Queen (8-neighbour) or Rook (4-neighbour) connectivity. OpenMP
#'   parallelisation scales efficiently to millions of grid cells.
#'
#' @param nrow Integer. Number of rows in the grid.
#' @param ncol Integer. Number of columns in the grid.
#' @param queen Logical. TRUE (default) for Queen moves, FALSE for Rook.
#'
#' @return A list of integer vectors of class \code{nb}. Indices are 1-based
#'   and attributes \code{region.id} and \code{queen} are set.
#'
#' @details
#'   Offsets for rook and (optionally) diagonal neighbours are pre-computed and
#'   applied in an OpenMP \code{for} loop. Each thread accumulates a private
#'   neighbour vector which is swapped into the main container to avoid
#'   locking.
#'
#' @examples
#' \dontrun{
#' nb <- grid_nb_omp(1024, 1024, queen = TRUE)
#' head(nb[[1]])
#' }
grid_nb_omp <- function(nrow, ncol, queen = TRUE) {
    .Call(`_geneSCOPE_grid_nb_omp`, nrow, ncol, queen)
}

#' @title Build Hexagonal (6-neighbour) Neighbourhood List in Parallel
#'
#' @description
#'   Creates a spatial neighbourhood list for a hex tiling laid out on a
#'   rectangular index with row-wise offsets (odd-r or even-r). See
#'   https://www.redblobgames.com/grids/hex-grids/ for conventions.
#'
#' @param nrow Integer. Number of rows in the logical lattice.
#' @param ncol Integer. Number of columns in the logical lattice.
#' @param oddr Logical. If TRUE, use odd-r layout (odd rows shifted right);
#'   otherwise use even-r layout (even rows shifted right).
#'
#' @return A list of integer vectors of class \code{nb}. Indices are 1-based
#'   and attributes \code{region.id} and \code{topology} ("hex-oddr" or
#'   "hex-evenr") are set. Attribute \code{queen} is set to FALSE for
#'   compatibility with existing code expecting a boolean.
#'
#' @examples
#' \dontrun{
#' nb_hex <- grid_nb_hex_omp(256, 512, oddr = TRUE)
#' }
grid_nb_hex_omp <- function(nrow, ncol, oddr = TRUE) {
    .Call(`_geneSCOPE_grid_nb_hex_omp`, nrow, ncol, oddr)
}

#' @title Build Hexagonal (6-neighbour) Neighbour List with column-offset (odd-q/even-q)
#'
#' @description
#'   Convenience wrapper that reuses the row-offset builder on a transposed
#'   lattice to implement pointy-top hex coordinates with column offsets
#'   (odd-q/even-q). Region indices are 1..(nrow*ncol) in column-major order
#'   consistent with mapping id = (gx-1)*nrow + gy.
#'
#' @param nrow Integer. Number of rows in the logical lattice.
#' @param ncol Integer. Number of columns in the logical lattice.
#' @param oddq Logical. If TRUE, odd columns are shifted; otherwise even.
#'
#' @return An \code{nb} list with attributes \code{region.id}, \code{queen}=FALSE,
#'   and \code{topology} set to \code{"hex-oddq"} or \code{"hex-evenq"}.
grid_nb_hexq_omp <- function(nrow, ncol, oddq = TRUE) {
    .Call(`_geneSCOPE_grid_nb_hexq_omp`, nrow, ncol, oddq)
}

#' @title Convert Neighbour List to Binary Sparse Matrix (dgCMatrix)
#'
#' @description
#'   Transforms an \code{nb} neighbourhood list into a column-compressed
#'   binary sparse matrix of class \code{dgCMatrix}. The routine streams the
#'   triplet representation in parallel with OpenMP and finally constructs the
#'   sparse matrix with Eigen.
#'
#' @param nb An object of class \code{nb}, typically returned by
#'   \code{grid_nb_omp()} or \pkg{spdep} functions.
#'
#' @return A \code{dgCMatrix} of dimension \eqn{n \times n} where \eqn{n} is
#'   the number of regions. Entries are \code{1} where two regions are
#'   adjacent and \code{0} elsewhere.
#'
#' @details
#'   The neighbour indices are 1-based; they are converted to 0-based before
#'   creation of the triplets for Eigen. Each thread accumulates its own
#'   vector of triplets to avoid synchronisation. After the parallel region
#'   all triplets are concatenated and the resulting sparse matrix is
#'   compressed in column-major order.
#'
#' @examples
#' \dontrun{
#' nb  <- grid_nb_omp(512, 512, queen = FALSE)
#' W   <- listw_B_omp(nb)
#' Matrix::nnzero(W) / length(nb)  # average degree
#' }
listw_B_omp <- function(nb) {
    .Call(`_geneSCOPE_listw_B_omp`, nb)
}

grid_nb <- function(nrow, ncol, queen = TRUE) {
    .Call(`_geneSCOPE_grid_nb`, nrow, ncol, queen)
}

nb2mat <- function(nb) {
    .Call(`_geneSCOPE_nb2mat`, nb)
}

#' @title Lee's L (single pass)
#' @description Computes the Lee's L statistic for all gene pairs using a zero-mean,
#'   sample-size–scaled formulation and a canonical S0 term. Matrix multiplication
#'   is threaded with OpenMP.
#' @param Xz  n × g numeric matrix of z-scored gene expression (rows = cells).
#' @param W   n × n sparse weight matrix in \code{dgCMatrix} format.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @return g × g dense matrix of Lee's L values.
#' @examples
#' \dontrun{
#' L <- lee_L(Xz, W, n_threads = 4)
#' }
lee_L <- function(Xz, W, n_threads = 1L) {
    .Call(`_geneSCOPE_lee_L`, Xz, W, n_threads)
}

#' @title Lee's L with cached W × Z
#' @description Same output as \code{lee_L} but first caches the
#'   spatially lagged matrix \eqn{WZ} to avoid repeated multiplications.
#' @param Xz  n × g numeric matrix of z-scored gene expression (rows = cells).
#' @param W   n × n sparse weight matrix in \code{dgCMatrix} format.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @return g × g dense matrix of Lee's L statistics.
lee_L_cache <- function(Xz, W, n_threads = 1L) {
    .Call(`_geneSCOPE_lee_L_cache`, Xz, W, n_threads)
}

#' @title Monte-Carlo permutation counts for Lee's L
#' @description Counts how many permuted Lee's L magnitudes are greater
#'   than or equal to the reference statistic, returning a g × g matrix
#'   of exceedance counts.
#' @param Xz n × g numeric matrix of z-scored expression (rows = cells).
#' @param W n × n sparse weight matrix in \code{dgCMatrix} format.
#' @param idx_mat n × B integer matrix of 0-based permutation indices.
#' @param L_ref g × g reference Lee's L matrix.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @return g × g integer matrix of exceedance counts.
lee_perm <- function(Xz, W, idx_mat, L_ref, n_threads = 1L) {
    .Call(`_geneSCOPE_lee_perm`, Xz, W, idx_mat, L_ref, n_threads)
}

#' @title Block-wise permutation counts for Lee's L
#' @description Performs Monte-Carlo permutations constrained within blocks
#'   (e.g. slides or images) and returns exceedance counts versus the reference
#'   statistic.
#' @param Xz n × g numeric matrix of z-scored expression (rows = cells).
#' @param W n × n sparse weight matrix in \code{dgCMatrix} format.
#' @param idx_mat n × B integer matrix of 0-based permutation indices.
#' @param block_ids n-length integer vector; identical IDs denote the same block.
#' @param L_ref g × g reference Lee's L matrix.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @return g × g integer matrix of exceedance counts.
lee_perm_block <- function(Xz, W, idx_mat, block_ids, L_ref, n_threads = 1L) {
    .Call(`_geneSCOPE_lee_perm_block`, Xz, W, idx_mat, block_ids, L_ref, n_threads)
}

#' @title Lee's L for a subset of columns
#' @description Computes Lee's L between a specified subset of columns
#'   (\code{cols0}) and all genes, returning a g × m matrix.
#' @param Xz n × g numeric matrix of z-scored expression (rows = cells).
#' @param W n × n sparse weight matrix in \code{dgCMatrix} format.
#' @param cols0 0-based integer vector of target column indices.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @return g × m dense matrix of Lee's L values.
lee_L_cols <- function(Xz, W, cols0, n_threads = 1L) {
    .Call(`_geneSCOPE_lee_L_cols`, Xz, W, cols0, n_threads)
}

#' @title Sparse Morisita's Iδ for gene–grid count matrices
#'
#' @description
#'   Computes Morisita's index Iδ for every gene (row) in a sparse
#'   count matrix, where columns are spatial grids.  Only the non-zero
#'   entries of each row are visited, so the runtime is \eqn{O(nnz)} and
#'   memory use is negligible.  The calculation is fully parallelised
#'   with OpenMP.
#'
#' @param G  \code{g × q} sparse numeric matrix (\code{dgCMatrix}) whose
#'   rows are genes and columns are grids.
#' @param n_threads Integer. Number of OpenMP threads to use (default 1).
#'
#' @return Numeric vector of length \code{g}.  Values are \code{NaN} for
#'   genes with fewer than two total molecules.
#'
#' @details
#'   For each gene the statistic is
#'   \deqn{I_\delta = q \frac{\sum_{i=1}^{q} x_i (x_i - 1)}
#'                     {\operatorname{tot}(\operatorname{tot}-1)},}
#'   where \eqn{x_i} is the count in grid \eqn{i} and
#'   \eqn{\operatorname{tot} = \sum_i x_i}.  The factor \eqn{q} corrects
#'   for the number of grids.
#'
#' @examples
#' \dontrun{
#' Idelta <- idelta_sparse_cpp(G, n_threads = 4)
#' summary(Idelta)
#' }
idelta_sparse_cpp <- function(G, n_threads = 1L) {
    .Call(`_geneSCOPE_idelta_sparse_cpp`, G, n_threads)
}

idelta <- function(G, n_threads = 1L) {
    .Call(`_geneSCOPE_idelta`, G, n_threads)
}

#' @title Block-wise Pearson correlation (parallel C++)
#'
#' @description
#'   Computes the Pearson correlation matrix for a column-centred numeric
#'   matrix \code{X} using a tiled (block-wise) multiplication strategy and
#'   OpenMP parallelism.  Only one block is kept in memory at a time, so the
#'   peak RAM footprint is \eqn{O(bs^2)} where \code{bs} is the block size.
#'
#' @param X  \eqn{n \times p} double matrix whose columns have already been
#'   mean-centred in R.
#' @param bs Integer. Number of variables (columns) per block; controls the
#'   memory–speed trade-off (default 2000).
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#'
#' @return A \eqn{p \times p} symmetric double matrix containing Pearson
#'   correlations.
#'
#' @details
#'   Column standard deviations are pre-computed, then each block pair
#'   multiplies \eqn{X_i^\top X_j / (n-1)} to obtain the covariance
#'   sub-matrix, which is scaled by the corresponding standard deviations
#'   to yield correlations.  Upper-triangular blocks are written first and
#'   mirrored into the lower triangle under a critical section to avoid
#'   write-race conditions.
#'
#' @examples
#' \dontrun{
#' R <- pearson_block_cpp(X, bs = 1500, n_threads = 4)
#' }
pearson_block_cpp <- function(X, bs = 2000L, n_threads = 1L) {
    .Call(`_geneSCOPE_pearson_block_cpp`, X, bs, n_threads)
}

pearson_cor <- function(X, bs = 2000L, n_threads = 1L) {
    .Call(`_geneSCOPE_pearson_cor`, X, bs, n_threads)
}

loess_residual_bootstrap <- function(x, y, strat, grid, B = 1000L, span = 0.45, deg = 1L, n_threads = 1L, k_max = -1L, keep_boot = TRUE, adjust_mode = 0L, ci_type = 0L, level = 0.95) {
    .Call(`_geneSCOPE_loess_residual_bootstrap`, x, y, strat, grid, B, span, deg, n_threads, k_max, keep_boot, adjust_mode, ci_type, level)
}

spmm_dgc_dense_f64 <- function(X, W, n_threads = 1L) {
    .Call(`_geneSCOPE_spmm_dgc_dense_f64`, X, W, n_threads)
}

spmm_dgc_dense_f32 <- function(X, W, n_threads = 1L) {
    .Call(`_geneSCOPE_spmm_dgc_dense_f32`, X, W, n_threads)
}

rp_sign_bits <- function(X, bits = 12L, n_tables = 6L, seed = 1L, n_threads = 1L) {
    .Call(`_geneSCOPE_rp_sign_bits`, X, bits, n_tables, seed, n_threads)
}

leeL_topk_candidates <- function(X, WX, row_ptr, indices, K_keep = 100L, n_threads = 1L) {
    .Call(`_geneSCOPE_leeL_topk_candidates`, X, WX, row_ptr, indices, K_keep, n_threads)
}

#' @title Optimised sparse Morisita–Horn similarity
#'
#' @description
#'   Computes pair‑wise Morisita–Horn similarity between rows of a sparse
#'   gene × grid count matrix using an edge list that specifies which pairs
#'   to evaluate.  The algorithm traverses the matrix in compressed‑row form
#'   (after transposing to columns) and uses a two‑pointer intersection to
#'   accumulate the shared counts.  Lambda terms are optionally corrected
#'   with Chao et al.’s bias estimator.  OpenMP parallelism is employed for
#'   both per‑row statistics and per‑edge similarities.
#'
#' @param G   \code{dgCMatrix}.  Sparse matrix of counts (genes × grids).
#' @param edges  2 × E unsigned integer matrix; each column holds a 0‑based
#'   row index pair \emph{i},\emph{j} for which to compute similarity.
#' @param use_chao Logical. Apply Chao bias correction (default \code{TRUE}).
#' @param nthreads Integer. Number of OpenMP threads (default 1).
#'
#' @return Numeric vector of length \code{E} with Morisita–Horn similarities.
#'
#' @details
#'   For each gene row \emph{g}, the total count \eqn{N_g}, the quadratic
#'   term \eqn{Q_g=\sum x^2}, and—if requested—the singletons (\eqn{f_1})
#'   and doubletons (\eqn{f_2}) are pre‑computed.  The standard estimator
#'   \eqn{\lambda_g = Q_g / N_g^2} is replaced by the Chao‐corrected form
#'   when \code{use_chao = TRUE}; negative or non‑finite values are truncated
#'   to 0, and if both corrected lambdas vanish the uncorrected values are
#'   used.  Final similarities are optionally rescaled by 10×, 100×, or 1000×
#'   so that the maximum is close to 1.
#'
#' @examples
#' \dontrun{
#'   sim <- morisita_horn_sparse_cpp(G, edges, use_chao = TRUE, nthreads = 4)
#'   summary(sim)
#' }
NULL

morisita_horn_sparse <- function(G, edges, use_chao = TRUE, nthreads = 1L) {
    .Call(`_geneSCOPE_morisita_horn_sparse`, G, edges, use_chao, nthreads)
}

#' @title Monte-Carlo permutation counts for Lee's L minus Pearson r difference (ultra-small chunk mode)
#' @description Special version for extremely large matrices that processes one row at a time
#' @param Xz n × g numeric matrix of z-scored expression (rows = cells).
#' @param W n × n sparse weight matrix in \code{dgCMatrix} format.
#' @param idx_mat n × B integer matrix of 0-based permutation indices.
#' @param gene_pairs g × 2 integer matrix of 0-based gene pair indices to test.
#' @param delta_ref Numeric vector of reference Delta values for each gene pair.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @return Integer vector of exceedance counts for each gene pair.
delta_lr_perm_tiny <- function(Xz, W, idx_mat, gene_pairs, delta_ref, n_threads = 1L) {
    .Call(`_geneSCOPE_delta_lr_perm_tiny`, Xz, W, idx_mat, gene_pairs, delta_ref, n_threads)
}

#' @title Block-wise permutation counts for Lee's L minus Pearson r difference (ultra-small chunk mode)
#' @description Special version for extremely large matrices that processes one row at a time
#' @param Xz n × g numeric matrix of z-scored expression (rows = cells).
#' @param W n × n sparse weight matrix in \code{dgCMatrix} format.
#' @param idx_mat n × B integer matrix of 0-based permutation indices.
#' @param block_ids n-length integer vector; identical IDs denote the same block.
#' @param gene_pairs g × 2 integer matrix of 0-based gene pair indices to test.
#' @param delta_ref Numeric vector of reference Delta values for each gene pair.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @return Integer vector of exceedance counts for each gene pair.
delta_lr_perm_block_tiny <- function(Xz, W, idx_mat, block_ids, gene_pairs, delta_ref, n_threads = 1L) {
    .Call(`_geneSCOPE_delta_lr_perm_block_tiny`, Xz, W, idx_mat, block_ids, gene_pairs, delta_ref, n_threads)
}

#' @title Monte-Carlo permutation counts for Lee's L minus Pearson r difference
#' @description Performs permutation test to evaluate the significance of the
#'   difference between Lee's L and Pearson r correlation (Delta) for specific
#'   gene pairs. It counts how many permutations yield a Delta magnitude greater
#'   than or equal to the reference Delta.
#' @param Xz n × g numeric matrix of z-scored expression (rows = cells).
#' @param W n × n sparse weight matrix in \code{dgCMatrix} format.
#' @param idx_mat n × B integer matrix of 0-based permutation indices.
#' @param gene_pairs g × 2 integer matrix of 0-based gene pair indices to test.
#' @param delta_ref Numeric vector of reference Delta values for each gene pair.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @param chunk_size Integer. Size of chunks for processing large matrices (default 1000).
#' @return Integer vector of exceedance counts for each gene pair.
delta_lr_perm <- function(Xz, W, idx_mat, gene_pairs, delta_ref, n_threads = 1L, chunk_size = 1000L) {
    .Call(`_geneSCOPE_delta_lr_perm`, Xz, W, idx_mat, gene_pairs, delta_ref, n_threads, chunk_size)
}

#' @title Block-wise permutation counts for Lee's L minus Pearson r difference
#' @description Performs block-wise permutations to evaluate the significance of
#'   the difference between Lee's L and Pearson r correlation (Delta) for specific
#'   gene pairs, preserving spatial autocorrelation structure.
#' @param Xz n × g numeric matrix of z-scored expression (rows = cells).
#' @param W n × n sparse weight matrix in \code{dgCMatrix} format.
#' @param idx_mat n × B integer matrix of 0-based permutation indices.
#' @param block_ids n-length integer vector; identical IDs denote the same block.
#' @param gene_pairs g × 2 integer matrix of 0-based gene pair indices to test.
#' @param delta_ref Numeric vector of reference Delta values for each gene pair.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @param chunk_size Integer. Size of chunks for processing large matrices (default 1000).
#' @return Integer vector of exceedance counts for each gene pair.
delta_lr_perm_block <- function(Xz, W, idx_mat, block_ids, gene_pairs, delta_ref, n_threads = 1L, chunk_size = 1000L) {
    .Call(`_geneSCOPE_delta_lr_perm_block`, Xz, W, idx_mat, block_ids, gene_pairs, delta_ref, n_threads, chunk_size)
}

#' @title Monte-Carlo permutation counts for Lee's L minus Pearson r difference (CSR format)
#' @description Uses CSR format of spatial weights for better memory efficiency with huge matrices
#' @param Xz n × g numeric matrix of z-scored expression (rows = cells).
#' @param W_indices Integer vector of column indices for non-zero elements in CSR format.
#' @param W_values Numeric vector of values for non-zero elements in CSR format.
#' @param W_row_ptr Integer vector of row pointers in CSR format.
#' @param idx_mat n × B integer matrix of 0-based permutation indices.
#' @param gene_pairs g × 2 integer matrix of 0-based gene pair indices to test.
#' @param delta_ref Numeric vector of reference Delta values for each gene pair.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @param clamp_nonneg_r Logical; if TRUE clamp Pearson r below 0 to 0 before Delta.
#' @return Integer vector of exceedance counts for each gene pair.
delta_lr_perm_csr <- function(Xz, W_indices, W_values, W_row_ptr, idx_mat, gene_pairs, delta_ref, n_threads = 1L, clamp_nonneg_r = FALSE) {
    .Call(`_geneSCOPE_delta_lr_perm_csr`, Xz, W_indices, W_values, W_row_ptr, idx_mat, gene_pairs, delta_ref, n_threads, clamp_nonneg_r)
}

#' @title Block-wise permutation counts for Lee's L minus Pearson r difference (CSR format)
#' @description Block-wise version using CSR format of spatial weights for memory efficiency
#' @param Xz n × g numeric matrix of z-scored expression (rows = cells).
#' @param W_indices Integer vector of column indices for non-zero elements in CSR format.
#' @param W_values Numeric vector of values for non-zero elements in CSR format.
#' @param W_row_ptr Integer vector of row pointers in CSR format.
#' @param idx_mat n × B integer matrix of 0-based permutation indices.
#' @param block_ids n-length integer vector; identical IDs denote the same block.
#' @param gene_pairs g × 2 integer matrix of 0-based gene pair indices to test.
#' @param delta_ref Numeric vector of reference Delta values for each gene pair.
#' @param n_threads Integer. Number of OpenMP threads (default 1).
#' @param clamp_nonneg_r Logical; if TRUE clamp Pearson r below 0 to 0 before Delta.
#' @return Integer vector of exceedance counts for each gene pair.
delta_lr_perm_csr_block <- function(Xz, W_indices, W_values, W_row_ptr, idx_mat, block_ids, gene_pairs, delta_ref, n_threads = 1L, clamp_nonneg_r = FALSE) {
    .Call(`_geneSCOPE_delta_lr_perm_csr_block`, Xz, W_indices, W_values, W_row_ptr, idx_mat, block_ids, gene_pairs, delta_ref, n_threads, clamp_nonneg_r)
}

consensus_coo_cpp <- function(memb, thr = 0.0, n_threads = 1L) {
    .Call(`_geneSCOPE_consensus_coo_cpp`, memb, thr, n_threads)
}

#' @title 检测当前编译/运行环境 64 位索引支持
#' @description 返回是否具备典型 64 位指针与 size_t (>=8 字节)，
#'   供在 R 端决定是否安全处理超大矩阵/稀疏结构（>2^31 行/列时需要）。
#' @return TRUE/FALSE
#' @export
test_64bit_support <- function() {
    .Call(`_geneSCOPE_test_64bit_support`)
}

