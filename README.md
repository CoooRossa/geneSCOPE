# geneSCOPE: gene Spatial Co-Occurrence of Pairwise Expression

[![R](https://img.shields.io/badge/R-%3E%3D4.4.1-blue.svg)](https://cran.r-project.org/)
[![License: GPL-3](https://img.shields.io/badge/License-GPL%203-yellow.svg)](https://opensource.org/licenses/GPL-3.0)
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)

**geneSCOPE** is an R package for comprehensive spatial gene expression analysis using Lee's L statistics. It provides a complete workflow for analyzing SVGs in spatial transcriptomics data, particularly designed for spatial transcriptomics datasets such as Xenium/Cosmx/Visium.

## Features

- **Spatial Statistics**: Compute Lee's L statistics for spatial gene co-expression analysis
- **Gene Network Analysis**: Build and visualize gene co-expression networks with spatial context
- **Gene Clustering**: Identify spatially co-expressed gene modules using advanced clustering algorithms
- **Quality Control & Visualization**: Plot-ready QC and exploratory views for grids, single cells, and modules
- **High Performance**: Optimized C++ implementations for large-scale spatial datasets
- **Flexible Workflow**: Modular design allowing customization for different analysis needs

## Installation

### Installation

#### Option 1 (Recommended): Conda-heavy install (pin most deps in conda)

1. Use conda to install and lock dependencies (including R ≥ 4.4.1):
```bash
conda create -n genescope -c conda-forge -c bioconda \
  "r-base>=4.4.1" r-devtools r-xml2 r-sf r-data.table r-dplyr r-foreach \
  r-ggplot2 r-ggraph r-ggrepel r-igraph r-scales r-tidyr r-arrow \
  r-rcpparmadillo r-rcppeigen r-future.apply r-ggforce r-ggnewscale \
  r-spdep r-rhpcblasctl bioconductor-rhdf5
conda activate genescope
```
   This keeps most compiled deps managed by conda for better reproducibility.

2. Inside that environment, install only geneSCOPE via R (conda already provides the deps):
```r
if (!requireNamespace("devtools", quietly = TRUE)) install.packages("devtools")
devtools::install_github("CoooRossa/geneSCOPE")
```

#### Option 2: Pure R install (no conda)

- Ensure your system R is **≥ 4.4.1**.
- Launch R and install everything directly:
```r
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")

install.packages(c(
  "data.table","dplyr","foreach","ggplot2","ggraph","ggrepel",
  "igraph","scales","sf","tidyr","arrow","RcppArmadillo","RcppEigen",
  "future.apply","ggforce","ggnewscale","spdep","rhpcBLASctl","devtools"
))
BiocManager::install(c("rhdf5"))
devtools::install_github("CoooRossa/geneSCOPE")
```

## Data-Type Workflows

The examples below split the pipeline by platform. Replace the placeholder paths with your own directories; no specific gene or sample identifiers are needed.

### Xenium

```r
library(geneSCOPE)

xenium_path <- "<XENIUM_DATA_DIR>"  # path to Xenium export directory

# 1) Create SCOPE object from raw data
xenium <- createSCOPE(
    data_dir = xenium_path,  # input directory
    grid_length = c(30),     # grid size (µm) for binning; 30 works well for ~100k cells
    seg_type = "cell",       # segmentation type used for filtering/visualization
    ncores = 32,             # CPU cores for parallel parsing
    # If your data contain extra non-gene signals, extend the default exclude_prefixes:
    # exclude_prefixes = c("Unassigned","NegControl","Background","DeprecatedCodeword","SystemControl","Negative","YOUR_PREFIX")
)

# 2) Attach single-cell matrices (optional but recommended)
xenium <- addSingleCells(
    scope_obj = xenium,      # SCOPE object to update
    data_dir = xenium_path   # same directory containing single-cell outputs
)

# 3) Normalize grid-level molecule counts
xenium <- normalizeMoleculesInGrid(
    scope_obj = xenium,
    grid_name = "grid30"     # grid generated by createSCOPE
)

# 4) Normalize single-cell expression (optional)
xenium <- normalizeSingleCells(
    scope_obj = xenium
)

# 5) Build spatial weight matrix
xenium <- computeWeights(
    scope_obj = xenium,
    grid_name = "grid30"    # match grid used above
)

# 6) Compute Lee's L statistics
xenium <- computeL(
    scope_obj = xenium,
    grid_name = "grid30",
    ncores = 32             # parallel workers for L calculation
)

# 7) Cluster genes into spatial modules
xenium <- clusterGenes(
    scope_obj = xenium,
    grid_name = "grid30",
    resolution = 0.1,                       # lower values keep more genes per module
    pct_min = "q95",                        # retain genes above 95th percentile frequency
    cluster_name = "q95_r0.1_g30",          # label for module membership
    graph_slot_name = "q95_r0.1_g30",       # graph storage graph slot
    consensus_thr = 0.95,                   # consensus threshold for stability
    n_restart = 100                         # number of Leiden restarts
)

# 8) Correlate expression (single-cell level by default)
xenium <- computeCorrelation(
    scope_obj = xenium,                     # SCOPE object
    level = "cell",                         # correlation level; set "grid" for grid bins
    layer = "logCPM",                       # expression layer to correlate; use "Xz" at grid level
    method = "pearson",                     # correlation metric
    blocksize = 2000,                       # chunk size for memory control
    ncores = 32                             # parallel workers
)       

# 9) Fit L vs R loess curve for significance control
xenium <- computeLvsRCurve(
    scope_obj = xenium,
    level = "cell",                         # match correlation level
    grid_name = "grid30",
    ncore = 32,                             # CPU cores
    downsample = 0.05,                      # fraction of observations to subsample
    k_max = 2000,                           # maximum neighbors for loess
    n_strata = 1000,                        # number of strata for sampling
    min_rel_width = 0.15,                   # minimum relative span width
    widen_span = 0.1,                       # span widening factor
    curve_name = "l_vs_r_curve"             # name for stored curve
)

# 10) Retrieve top L vs R gene pairs
top_pairs <- getTopLvsR(
    scope_obj = xenium,
    grid_name = "grid30",
    pear_level = "cell",                    # level used for correlation input
    L_range = c(0.0, 1),                    # keep pairs with L in this interval
    top_n = 100,                            # number of pairs returned
    ncores = 32,
    direction = "largest",                  # sort by largest L
    curve_layer = "l_vs_r_curve",           # curve used for filtering
    CI_rule = "remove_within"               # confidence interval rule
)

gene_a <- top_pairs$gene1[1]
gene_b <- top_pairs$gene2[1]

# 11) Compute density maps for the top pair
xenium <- computeDensity(
    scope_obj = xenium,
    grid_name = "grid30",     # grid to aggregate on
    layer_name = "counts",    # layer used for density
    normalize_method = "none",# no normalization applied
    density_name = gene_a,    # output density layer name
    genes = gene_a            # target gene list
)
xenium <- computeDensity(
    scope_obj = xenium,
    grid_name = "grid30",     # same grid as above
    layer_name = "counts",    # layer used for density
    normalize_method = "none",# no normalization applied
    density_name = gene_b,    # output density layer name
    genes = gene_b            # target gene list
)

# 12) Plot paired densities
plotDensity(
    scope_obj = xenium,
    density1_name = gene_a,  # first density layer
    density2_name = gene_b,  # second density layer
    max.cutoff1 = 0.25,      # cap for density1 color scale
    max.cutoff2 = 0.25,      # cap for density2 color scale
    seg_type = "cell",       # segmentation type to draw
    grid_name = "grid30",    # grid overlay
    alpha_seg = 0.5,         # segmentation transparency
    alpha1 = 1,              # density1 transparency
    alpha2 = 0.5,            # density2 transparency
    legend_digits = 3,       # digits in legend
    bar_offset = 0.02,       # legend offset
    arrow_pt = 2,            # arrow point size
    scale_text_size = 1.5    # legend text size
)
```

### CosMx

Optional pre-processing for faster reads and ROI generation:
```bash
# Minimal Python env for cosmx_flatfiles_to_parquet.py + auto_rois_from_fovs.py
conda create -n cosmx-py311 -c conda-forge python=3.11 pandas numpy pyarrow matplotlib
conda activate cosmx-py311
```

Run the Python utilities from the repository root. If unsure of the path:
```bash
REPO_ROOT=$(git rev-parse --show-toplevel)
```

```bash
# Convert CosMx flat files to parquet (improves load speed)
python path/to/geneSCOPE/cosmx_flatfiles_to_parquet.py \
  --root "<COSMX_ROOT_DIR>" \
  --pixel-size-um 0.120280945 \
  --build-transcripts --build-cells --build-segmentation \
  --overwrite

# If you don't have QuPath ROIs, build ROI bundles automatically from FOVs
python path/to/geneSCOPE/auto_rois_from_fovs.py \
  --root "<COSMX_ROOT_DIR>" \
  --method graph --k 0 --min-fovs 3 \
  --eps-um 800 \
  --margin-um 5 \
  --out-dir "<OUTPUT_ROI_DIR>"
```

```r
library(geneSCOPE)

cosmx_path <- "<COSMX_DATA_DIR>"

# 1) Create SCOPE object
cosmx <- createSCOPE(
    data_dir = cosmx_path,
    grid_length = c(30),
    seg_type = "cell",
    verbose = TRUE,
    ncores = 32,
    flip_y = FALSE,
    # If your data contain extra non-gene signals, extend the default exclude_prefixes:
    # exclude_prefixes = c("Unassigned","NegControl","Background","DeprecatedCodeword","SystemControl","Negative","YOUR_PREFIX")
)

# 2) Add single-cell data
cosmx <- addSingleCells(
    scope_obj = cosmx,
    data_dir = cosmx_path
)

# 3) Normalize grid binning data
cosmx <- normalizeMoleculesInGrid(
    scope_obj = cosmx,
    grid_name = "grid30"
)

# 4) Normalize single-cell data
cosmx <- normalizeSingleCells(
    scope_obj = cosmx
)

# 5) Compute spatial weights
cosmx <- computeWeights(
    scope_obj = cosmx,
    grid_name = "grid30"
)

# 6) Compute Lee's L
cosmx <- computeL(
    scope_obj = cosmx,
    grid_name = "grid30",
    ncores = 32
)

# 7) Cluster genes
cosmx <- clusterGenes(
    scope_obj = cosmx,
    grid_name = "grid30",
    resolution = 0.1, # keep more genes in modules
    pct_min = "q95",
    cluster_name = "q95_r0.1_g30",
    graph_slot_name = "q95_r0.1_g30",
    consensus_thr = 0.95,
    n_restart = 100
)

# 8) Correlate genes (defaults to cell level, logCPM layer)
cosmx <- computeCorrelation(
    scope_obj = cosmx,
    ncores = 32
)

# 9) Fit L vs R curve
cosmx <- computeLvsRCurve(
    scope_obj = cosmx,
    level = "cell",
    grid_name = "grid30",
    ncore = 64,
    downsample = 0.05,
    k_max = 2000,
    n_strata = 1000,
    min_rel_width = 0.15,
    widen_span = 0.1,
    curve_name = "l_vs_r_curve"
)

# 10) Extract top L vs R pairs
top_pairs_cosmx <- getTopLvsR(
    scope_obj = cosmx,
    grid_name = "grid30",
    pear_level = "cell",
    L_range = c(0.0, 1),
    top_n = 100,
    ncores = 32,
    direction = "largest",
    pval_mode = "uniform",
    curve_layer = "l_vs_r_curve",
    CI_rule = "remove_within"
)
```

### Visium

Prerequisites (Seurat + SCT). Current Visium support assumes SCT normalization; lighter pipelines are in planning:
```r
# install sctransform >= 0.3.3, requires Seurat >= 4.1
install.packages(c("Seurat", "sctransform"))
```
```r
library(geneSCOPE)

visium_path <- "<VISIUM_DATA_DIR>"

# 1) Create SCOPE object (Visium ST data)
visium <- createSCOPE(
    data_dir = visium_path,
    flip_y = FALSE,
    # If your data contain extra non-gene signals, extend the default exclude_prefixes:
    # exclude_prefixes = c("Unassigned","NegControl","Background","DeprecatedCodeword","SystemControl","Negative","YOUR_PREFIX")
)

# 2) Compute spatial weights on Visium grid
visium <- computeWeights(
    scope_obj = visium,
    grid_name = "grid55"
)

# 3) Compute Lee's L with SCT layer and prescreening
visium <- computeL_visium(
    scope_obj = visium,
    grid_name = "grid55",
    norm_layer = "SCT",
    use_idelta = TRUE,
    S_target = 500,
    ncores = 32
)

# 4) Cluster genes using Lee's L from SCT layer
visium <- clusterGenes(
    scope_obj = visium,
    grid_name = "grid55",
    resolution = 0.1,
    lee_stats_layer = "LeeStats_SCT",
    pct_min = "q95",
    cluster_name = "q95_r0.1_g30",
    graph_slot_name = "q95_r0.1_g30",
    consensus_thr = 0.95,
    n_restart = 100
)

# 5) Correlate genes at grid level
visium <- computeCorrelation(
    scope_obj = visium,
    level = "grid",
    layer = "SCT",
    method = "pearson",
    blocksize = 2000,
    ncores = 32
)

# 6) Fit L vs R curve at grid level
visium <- computeLvsRCurve(
    scope_obj = visium,
    level = "grid",
    lee_stats_layer = "LeeStats_SCT",
    grid_name = "grid55",
    ncore = 32,
    downsample = 0.001,
    k_max = 2000,
    n_strata = 1000,
    min_rel_width = 0.15,
    widen_span = 0.1,
    curve_name = "l_vs_r_curve"
)

# 7) Retrieve top L vs R pairs
visium_top_pairs <- getTopLvsR(
    scope_obj = visium,
    lee_stats_layer = "LeeStats_SCT",
    grid_name = "grid55",
    pear_level = "grid",
    L_range = c(0.0, 1),
    top_n = 100,
    ncores = 32,
    direction = "largest",
    curve_layer = "l_vs_r_curve",
    CI_rule = "remove_within"
)
```

### Gene Module Density (optional)

Use module-level density mapping for any dataset after clustering:

```r
xenium <- computeDensity(
    scope_obj = xenium,
    grid_name = "grid30",
    layer_name = "counts",                        # expression layer to bin
    cluster_col = "q95_r0.1_g30", # column storing module IDs
    cluster_num = 1,                              # module index to visualize
    density_name = "q95_r0.1_g30_density_cluster_1", # output layer name
    normalize_method = "global_gene"              # normalize by total counts across bins
)

plotDensity(
    scope_obj = xenium,
    density1_name = "q95_r0.1_g30_density_cluster_1",
    grid_name = "grid30",
    palette1 = "red",
    max.cutoff1 = 0.5,
    alpha1 = 1
)
```

## Workflow Overview

The geneSCOPE analysis pipeline consists of three main parts:

### Part 1: Basic Data Processing
- **Object Construction**: Create SCOPE object from Xenium/CosMx/Visium data
- **Data Integration**: Add single cell data and normalize expression
- **Quality Control**: Optional preliminary visualizations

### Part 2: Spatial Analysis
- **Spatial Statistics**: Compute Lee's L statistics for spatial gene relationships
- **Correlation Analysis**: Calculate gene expression correlations
- **Curve Fitting**: Optional L vs R curve analysis for validation

### Part 3: Gene Clustering and Networks
- **Gene Clustering**: Identify spatially co-expressed gene modules
- **Network Construction**: Build gene co-expression networks
- **Visualization**: Create module footprints and density maps

## Key Functions

| Function | Description |
|----------|-------------|
| `createSCOPE()` | Create SCOPE object from spatial data |
| `computeWeights()` | Calculate spatial weight matrix |
| `computeL()` | Calculate Lee's L spatial statistics |
| `computeCorrelation()` | Calculate gene expression correlations |
| `getTopLvsR()` | Identify top gene pairs with spatial correlation differences |
| `clusterGenes()` | Perform spatial gene clustering |

## Data Format

geneSCOPE works with Xenium spatial transcriptomics data format, including:

- Gene expression count matrices
- Spatial coordinate information
- Cell segmentation data

## Citation

If you use geneSCOPE in your research, please cite:

```
```

## License

This project is licensed under the GPL-3 License - see the [LICENSE](LICENSE) file for details.

## Support

- **Issues**: Report bugs or request features via [GitHub Issues](../../issues)
- **Email**: Contact the maintainers at [0322704@ed.tus.ac.jp]

---

**Note**: This package is under active development. Some features may change in future versions. Please check the [releases page](../../releases) for the latest stable version.
