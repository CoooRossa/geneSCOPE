% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api_clustering.R
\name{clusterGenes}
\alias{clusterGenes}
\title{Cluster genes on a consensus graph.}
\usage{
clusterGenes(
  scope_obj,
  grid_name = NULL,
  stats_layer = "LeeStats_Xz",
  lee_stats_layer = NULL,
  similarity_slot = "L",
  significance_slot = "FDR",
  min_cutoff = 0,
  L_min = NULL,
  use_significance = TRUE,
  use_FDR = NULL,
  significance_max = 0.05,
  FDR_max = NULL,
  pct_min = "q0",
  drop_isolated = TRUE,
  algo = c("leiden", "louvain", "hotspot-like"),
  stage2_algo = NULL,
  resolution = 1,
  gamma = 1,
  objective = c("CPM", "modularity"),
  cluster_name = NULL,
  use_log1p_weight = TRUE,
  use_consensus = TRUE,
  graph_slot_name = "g_consensus",
  n_restart = 100,
  consensus_thr = 0.95,
  K = NULL,
  min_module_size = 5,
  CI95_filter = NULL,
  CI_rule = NULL,
  curve_layer = NULL,
  use_mh_weight = NULL,
  use_cmh_weight = NULL,
  mh_slot = NULL,
  cmh_slot = NULL,
  post_smooth = TRUE,
  post_smooth_quant = c(0.05, 0.95),
  post_smooth_power = 0.5,
  enable_subcluster = TRUE,
  sub_min_size = 10,
  sub_min_child_size = 5,
  sub_resolution_factor = 1.3,
  sub_within_cons_max = 0.5,
  sub_conductance_min = 0.6,
  sub_improve_within_cons_min = 0.07,
  sub_max_groups = 3,
  enable_qc_filter = TRUE,
  qc_gene_intra_cons_min = 0.25,
  qc_gene_best_out_cons_min = 0.6,
  qc_gene_intra_weight_q = 0.05,
  keep_cross_stable = TRUE,
  min_cluster_size = 2,
  keep_stage1_backbone = TRUE,
  backbone_floor_q = 0.02,
  return_report = FALSE,
  verbose = TRUE,
  ncores = NULL,
  mode = c("auto", "safe", "aggressive", "fast"),
  large_n_threshold = 1000L,
  nk_condaenv = NULL,
  nk_conda_bin = NULL,
  nk_python = NULL,
  nk_leiden_iterations = 10L,
  nk_leiden_randomize = TRUE,
  aggr_future_workers = 2L,
  aggr_batch_size = NULL,
  future_globals_min_bytes = 2 * 1024^3,
  profile_timing = FALSE
)
}
\arguments{
\item{scope_obj}{A `scope_object` containing graph/stat layers.}

\item{grid_name}{Optional grid layer name; defaults to the active layer.}

\item{stats_layer}{Statistics layer name (e.g. `"LeeStats_Xz"`).}

\item{lee_stats_layer}{Optional alias of `stats_layer` (preferred for clarity).}

\item{similarity_slot}{Name of similarity matrix slot within the stats layer (default `"L"`).}

\item{significance_slot}{Name of significance/FDR matrix slot within the stats layer (default `"FDR"`).}

\item{min_cutoff}{Minimum similarity cutoff (alias: `L_min`).}

\item{L_min}{Deprecated alias of `min_cutoff`.}

\item{use_significance}{Whether to apply significance/FDR gating.}

\item{use_FDR}{Deprecated alias of `use_significance`.}

\item{significance_max}{Maximum allowed significance/FDR (alias: `FDR_max`).}

\item{FDR_max}{Deprecated alias of `significance_max`.}

\item{pct_min}{Gene prevalence filter used in stage1 (e.g. `"q0"`).}

\item{drop_isolated}{Whether to drop isolated nodes before clustering.}

\item{algo}{Stage1 clustering algorithm (`leiden`, `louvain`, `hotspot-like`).}

\item{stage2_algo}{Optional override of stage2 algorithm (defaults to `algo`).}

\item{resolution}{Resolution parameter passed to Leiden/Louvain.}

\item{gamma}{Gamma parameter used by some clustering backends.}

\item{objective}{Optimization objective (backend-specific; e.g. `"CPM"` or `"modularity"`).}

\item{cluster_name}{Column name to store final memberships under `scope_obj@meta.data`.}

\item{use_log1p_weight}{Whether to log1p-transform edge weights before clustering.}

\item{use_consensus}{Whether to build/use a consensus graph across restarts.}

\item{graph_slot_name}{Graph slot used to drive clustering (e.g., consensus graph).}

\item{n_restart}{Number of random restarts for consensus building.}

\item{consensus_thr}{Consensus threshold applied when building the final graph.}

\item{K}{Hotspot-like neighbourhood parameter (backend-specific; optional).}

\item{min_module_size}{Minimum module size for hotspot-like backend.}

\item{CI95_filter}{Deprecated flag; use `CI_rule` instead.}

\item{CI_rule}{Optional confidence-interval filtering rule (`remove_within`, `remove_outside`).}

\item{curve_layer}{Name of curve layer used by CI filtering (required when `CI_rule` is set).}

\item{use_mh_weight}{Whether to use MH weighting (auto-detected from `mh_slot` when NULL).}

\item{use_cmh_weight}{Deprecated alias of `use_mh_weight`.}

\item{mh_slot}{Name of MH weight slot.}

\item{cmh_slot}{Deprecated alias of `mh_slot`.}

\item{post_smooth}{Whether to apply post-smoothing of weights/scores.}

\item{post_smooth_quant}{Quantile range for post-smoothing.}

\item{post_smooth_power}{Power used in post-smoothing.}

\item{enable_subcluster}{Whether to enable the subclustering pass.}

\item{sub_min_size}{Minimum parent-cluster size eligible for subclustering.}

\item{sub_min_child_size}{Minimum subcluster size.}

\item{sub_resolution_factor}{Resolution multiplier for subclustering.}

\item{sub_within_cons_max}{Maximum within-consensus threshold for subclustering.}

\item{sub_conductance_min}{Minimum conductance threshold for subclustering.}

\item{sub_improve_within_cons_min}{Minimum improvement threshold for within-consensus to accept a subcluster.}

\item{sub_max_groups}{Maximum number of subclusters produced per parent.}

\item{enable_qc_filter}{Whether to apply QC-based gene/module filtering.}

\item{qc_gene_intra_cons_min}{QC: minimum within-module consensus threshold.}

\item{qc_gene_best_out_cons_min}{QC: minimum "best outside" consensus threshold.}

\item{qc_gene_intra_weight_q}{QC: quantile for intra-module weight thresholding.}

\item{keep_cross_stable}{Whether to retain cross-stable edges/modules.}

\item{min_cluster_size}{Minimum allowed final cluster size.}

\item{keep_stage1_backbone}{Whether to keep stage1 backbone edges.}

\item{backbone_floor_q}{Quantile floor for backbone retention.}

\item{return_report}{When `TRUE`, returns both updated scope object and a report list.}

\item{verbose}{Emit progress messages when TRUE.}

\item{ncores}{Number of threads to use (clamped to available cores).}

\item{mode}{Runtime mode (`auto`, `safe`, `aggressive`, `fast`).}

\item{large_n_threshold}{Threshold controlling large-N heuristics.}

\item{nk_condaenv}{Optional conda environment name for Networkit/Python backends.}

\item{nk_conda_bin}{Optional path to conda binary.}

\item{nk_python}{Optional explicit python path for Networkit backends.}

\item{nk_leiden_iterations}{Leiden iterations (Networkit backend).}

\item{nk_leiden_randomize}{Whether to randomize Leiden (Networkit backend).}

\item{aggr_future_workers}{Number of future workers used by aggressive modes.}

\item{aggr_batch_size}{Batch size used in aggressive modes.}

\item{future_globals_min_bytes}{Minimum globals size threshold for futures.}

\item{profile_timing}{Whether to collect timing measurements for the returned report.}
}
\value{
If `return_report = FALSE` (default), returns the updated `scope_object`.
If `return_report = TRUE`, returns `list(scope_obj = <scope_object>, report = <list>)`.
}
\description{
Runs the stage1/stage2 gene clustering pipeline on a `scope_object`, using a
similarity/statistics layer (typically produced by `computeL()` / `computeMH()`)
and writing cluster assignments back into `scope_obj@meta.data`.
}
\examples{
\dontrun{
scope_obj <- createSCOPE(data_dir = "/path/to/output_dir",ã€€grid_length = 30)
scope_obj <- normalizeMoleculesInGrid(scope_obj, grid_name = "grid30")
scope_obj <- computeL(scope_obj, grid_name = "grid30")
scope_obj <- computeMH(scope_obj, grid_name = "grid30")
scope_obj <- clusterGenes(scope_obj, grid_name = "grid30", pct_min = "q50", n_start = 100, consensus_thr = 0.9, resolution = 0.5)
}
}
\seealso{
`computeL()`, `computeMH()`, `plotNetwork()`, `plotDendroNetwork()`
}
