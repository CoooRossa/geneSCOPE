% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/8.IDelta.r
\name{computeIDelta}
\alias{computeIDelta}
\title{Compute Morisita's Iδ per gene and store in a scope_object}
\usage{
computeIDelta(
  scope_obj,
  grid_name = NULL,
  level = c("grid", "cell"),
  ncore = 4,
  verbose = getOption("geneSCOPE.verbose", TRUE)
)
}
\arguments{
\item{scope_obj}{A \code{scope_object} that already contains a populated
\code{@grid} slot with \code{counts} and
\code{grid_info}, or \code{@cells} slot with count matrix.}

\item{grid_name}{Character. Name of the grid sub-layer to use when
\code{level = "grid"}. If \code{NULL} and only one layer
exists it is chosen automatically.}

\item{level}{Character. Either \code{"grid"} (default) to compute Iδ
across spatial grids, or \code{"cell"} to compute across
single cells.}

\item{ncore}{Integer. Number of OpenMP threads passed to the
C++ routine (default 4).}

\item{verbose}{Logical. Whether to print progress messages (default TRUE).}
}
\value{
The modified \code{scope_object} is returned invisibly.
}
\description{
Builds a sparse gene × grid/cell count matrix, computes Morisita's
index Iδ for every gene using the parallel C++ kernel
\code{idelta_sparse_cpp()}, and writes the raw scores back to
\code{scope_obj}.  The result is also copied into
\code{scope_obj@meta.data} under a column named
\code{<grid_name>_iDelta_raw} or \code{cell_iDelta_raw}.
}
\details{
When \code{level = "grid"}, only grid–gene pairs with positive molecule
counts are considered. When \code{level = "cell"}, the function uses the
count matrix from \code{scope_obj@cells$counts}. In both cases, memory
usage scales with the number of non-zero entries. Genes with fewer than
two total molecules receive \code{NaN}.
}
\examples{
\dontrun{
# Grid-level Iδ
coord <- computeIDelta(coord, grid_name = "25um", level = "grid", ncore = 8)

# Single-cell Iδ
coord <- computeIDelta(coord, level = "cell", ncore = 8)
}
}
