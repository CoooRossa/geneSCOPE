% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/api_leesL.R
\name{computeL}
\alias{computeL}
\title{Compute Lee's L statistic.}
\usage{
computeL(
  scope_obj,
  grid_name = NULL,
  genes = NULL,
  within = TRUE,
  ncores = 1,
  block_side = 8,
  perms = 1000,
  block_size = 64,
  L_min = 0,
  norm_layer = "Xz",
  lee_stats_layer_name = NULL,
  legacy_formula = FALSE,
  mem_limit_GB = 2,
  chunk_size = 32L,
  use_bigmemory = TRUE,
  backing_path = tempdir(),
  cache_inputs = TRUE,
  verbose = TRUE,
  ncore = NULL
)
}
\arguments{
\item{scope_obj}{A `scope_object` with at least one populated `@grid` slot.}

\item{grid_name}{Name of the grid layer to process (auto-selected if only one exists).}

\item{genes}{Optional subset of genes to include.}

\item{within}{If `TRUE`, restricts analysis to the selected gene set on both axes.}

\item{ncores}{Number of cores for parallel processing.}

\item{block_side}{Number of grid cells per side for block partitioning.}

\item{perms}{Number of permutations for Monte-Carlo p-values.}

\item{block_size}{Number of permutations processed per batch.}

\item{L_min}{Similarity threshold used when building QC similarity graphs.}

\item{norm_layer}{Name of the normalised expression layer (default `"Xz"`).}

\item{lee_stats_layer_name}{Output statistics layer name (auto-generated when NULL).}

\item{legacy_formula}{Use legacy denominator for compatibility.}

\item{mem_limit_GB}{RAM threshold that triggers streaming mode.}

\item{chunk_size}{Number of columns processed per chunk in streaming mode.}

\item{use_bigmemory}{Whether to use file-backed matrices for large computations.}

\item{backing_path}{Directory for temporary files (default `tempdir()`).}

\item{cache_inputs}{Whether to .cache preprocessed inputs for reuse across calls.}

\item{verbose}{Whether to emit progress messages.}

\item{ncore}{Deprecated alias of `ncores`.}
}
\value{
The modified `scope_object`.
}
\description{
Computes Lee's L for gene pairs using a grid-level expression layer, stores
results under a statistics layer in `scope_obj@stats`, and returns the updated
object.
}
\examples{
\dontrun{
scope_obj <- createSCOPE(data_dir = "/path/to/output_dir", grid_length = 30)
scope_obj <- normalizeMoleculesInGrid(scope_obj, grid_name = "grid30")
scope_obj <- computeWeights(scope_obj, grid_name = "grid30")
scope_obj <- computeL(scope_obj, grid_name = "grid30", ncores = 16)
}
}
\seealso{
`computeWeights()`, `computeMH()`, `computeLvsRCurve()`, `getTopLvsR()`
}
