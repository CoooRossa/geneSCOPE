% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/2.Normalization.r
\name{normalizeSingleCells}
\alias{normalizeSingleCells}
\title{Add log-CPM normalized matrix to a scope_object}
\usage{
normalizeSingleCells(
  scope_obj,
  input_layer = "counts",
  output_layer = "logCPM",
  scale_factor = 10000,
  verbose = TRUE
)
}
\arguments{
\item{scope_obj}{A \code{scope_object}.}

\item{input_layer}{Character. Name of the existing layer to read
(must be a \code{dgCMatrix} inside
\code{scope_obj@cells}); default \code{"counts"}.}

\item{output_layer}{Character. Name of the layer to write to
(will overwrite if exists); default \code{"logCPM"}.}

\item{scale_factor}{Numeric. Library size each cell is scaled to
before log1p; default 1e4.}

\item{verbose}{Logical. Whether to print progress messages (default TRUE).}
}
\value{
The modified \code{scope_object} (invisibly).
}
\description{
Reads the specified layer (default \code{"counts"}) from
\code{scope_obj@cells}, converts to counts-per-\code{scale_factor}
(default 10,000), applies \code{log1p}, and stores the result as
a new layer (default \code{"logCPM"}). The modified object is
returned invisibly so you can overwrite the original variable.
}
\details{
Counts per million (CPM) are computed by dividing each cell's counts by its
total library size, multiplying by \code{scale_factor}, and finally applying
\code{log1p}. Because the matrix is stored in compressed sparse column (CSC)
form, these operations touch only the non-zero entries, preserving sparsity.

The resulting layer is functionally equivalent to Seurat's
\code{NormalizeData(method = "LogNormalize")}, but this implementation keeps
all steps sparse and avoids introducing Seurat as a dependency. The new
matrix is stored (or overwritten) in \code{scope_obj@cells[[output_layer]]};
no other slots are modified.
}
\examples{
\dontrun{
## Add log-CPM layer and inspect a housekeeping gene
P5.coord <- normalizeSingleCells(P5.coord)
}
}
